<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title></title>
</head>
<body>

    Design Patterns:
    ================

    Design Patterns are evolved as reusable solution to the problems that we encounter everyday of programing.
    Design patterns are essential in software development that provide proven solutions to common design problems

    They are generally targeted at solving the problems of object generations and integrations
    --23 classic design pattern created by Gang of Four

    Types:
    1. Creational
    2. Structural
    3. Behavioural

    1. Creational: [OBJECT CREATION]
    - This type deal with object creation and intialization.
    - This pattern gives the program more flexibility in deciding which object needs to be created for a given case.

    - It deals with object creation mechanisms.
    - They help in controlling the object instantiation process and provide flexibility in how objects are created.
    Eg: Signleton
    Factory
    Abstract Factory etc...


    2. Structural: [DECOUPLING OF INTERFACES AND CLASSES]
    - This type deal with class and object composition.
    - This pattern focuses on decoupling interface and implementation of classes and its objects.
    Eg: Adapter, Bridge etc..

    3. Behavioral: [COMMUNICATION B/W CLASS AND OBJECT]
    - This type deals with the communication b/w classes and objects
    Eg: Chain of Responsibility, Command, Interpreter etc...


    ========================================== CREATIONAL PATTERN==================================================================

    -----------------------------------------------------SINGLETON---------------------------------------------------------------

    SINGLETON PATTERN: -> Creational Type Pattern
    ------------------
    - Ensure that only object is created across the application
    - It controls concurrent access to the resourcse
    - It ensures there is only one object availabe across the application in a controlled state

    - In Multi threading, use lock on object instanciation logic that way it won't create multiple objects

    1. Classic Singleton
    2. Thread Safe Singleton
    3. Lazy Singleton
    4. Static Signleton

    Lazy Loading
    ------------
    - imporves the performance
    - avoid unnecessay load till the point object is accessed
    - reduces the memory footprint on the start-up
    - fatsrer application load

    Non-Lazy or Eager Loading
    -------------------------
    - Pre-Instantiation of the object
    - Commonly used in lower memory footprint

    STATIC VS SINGELTON
    -------------------
    - static is a keyword, singleton is a design pattern
    - static class contain only static memebers
    - sigleton is an object creational pattern with one instance of the class
    - singleton can implement interfaces, inherit from other classes and it align with OOPS concepts.
    - singleton object can be passed as reference
    - singleton supports object disposal
    - singleton object is stored in heap
    - singleton object can be cloned

    Use Cases:
    ----------
    -> Logging (exception or information logging)
    -> Managing a connection or a pool of connection to DB
    -> Printer spooling
    -> File
    -> Configuration
    -> Cache
    -> Session based shopping cart

    ------------------------------------------------FACTORY DESIGN PATTERN------------------------------------------------

    FACTORY DESIGN PATTERN: [creatinal pttern]
    -----------------------
    Define an interface for creating object, but let subclasses decide which class to instantiate.
    - creates object without exposing the creation logic to client and refer to newly created object using common interface.
    - It provides a factory, request factorty crate object instead of directly creating

    - Factory pattern creates object without exposing the creation logic to client and refer to newly created object using a common interface.

    *** The factory pattern solves this problem by providing an interface objects with exposing their concrete implementations.***

    Problem:
    Creating objects directly can lead to tight coupling b/w client code and concrete classes.
    Making it hard to adapt to changes or extend the system with new classes

    Solution:
    The factory pettern defines a factory class or method reponsible for creating objects.
    Client requests objects the factory using a common interface, allowing them to work with abstract types while leaving the concrete object creation to the factory

    uses			create
    client----------factory---------product
    here client uses product object, which is being created from factory without knowing logic

    Benifits of the Factory Pattern:
    --------------------------------
    - Encapsulating object creation and reducing coupling
    - Central point of control and configuration for object creation
    - Promotes Open-Closed principle
    - Testing and mocking of the client code(with out instantiating real object)


    ------------------------------------------------- Builder Pattern -------------------------------------------------------------
    Builder Pattern:
    ----------------
    Problem:
    When dealing with complex objects with many configuration options, constructors with numerous parameters become unwidely and error prone.
    Imagine you're creating an object, like a House, with many parts: walls, doors, windows, roof, etc.
    If you try to create this object directly in your code, the constructor can become very messy, especially
    if the object has a lot of optional configurations. This makes the code hard to read, maintain, and extend.

    *** The builder patterns simplifies object creation by seperation the construction process from the actual representaion. ***
    --- The builder pattern helps you to create complex objects step by step, instead of all at once.
    It makes code easier to understand and modify, especially when the object has many parts or options.


    Solution:
    The builder pattern solves the by dividing the construction process into smaller, manageale steps.
    Instead of passing all parameters at once, you create the object stp by step, setting each part separattely

    Here’s how it works:

    1. Builder Interface: Defines the steps needed to construct the object.
    2. Concrete Builder: Implements the steps defined in the builder interface to create the actual object.
    3. Director: Controls the construction process, guiding the builder to create the object in a specific order.
    4. Product: The final object that’s constructed.


    ========================================STRUCTURAL DESIGN PATTERNS===========================================================

    ------------------------------------------ADAPTER PATTERN--------------------------------------------------------

    Adapter Pattern:
    ----------------
    Problem:
    Integrating new components or libraries with incompatible interfaces into an existing system can be problematic.

    *** The adapter pattern allows incompatible components to work together by creating an adapter
    that acts as a bridge b/w the incompatible interfaces. ***

    Solution:
    This adapter pattern helps to create adapter class that implements the expected interface for the client code.
    This adpter class delegates calls to the methods of the adapted object, enabling it to interact with the client code
    without exposing the the incompatible interface.

    How It Works:
    > Adapter(MediaPlayerAdapter): Wraps the incompatible object(`VLCPlayer`) and makes it compatible with the `IMediaPlayer` interface.
    > Client(Main Method): Can now use the `VLCPlayer` as if it were a `IMediaPlayer`

    --> The Adapter Pattern useful when you need to integrate classes with incompatible interfaces.
    It allows you to use existing classes without modifying their code, making it easier to work with third-party libraries or legacy code.


    --------------------------------------------BRIDGE PATTERN---------------------------------------------------------

    Bridge Pattern:
    --------------
    Problem:
    Separating an abstraction from its implementaion is crucial in large software system to promote flexibility and maintainability.

    *** The bridge pattern is structural design pattern that separates an objects's abstraction(what it does)
    from its implementation(how it does), allowing them to evolve independently. ***

    *** The bridge pattern is a structural design pattern, that decouples an abstraction from its implementation,
    allowing them to vary independently. ***

    This pattern is useful when you want to avoid a permanent binding b/w an abstraction and its implementation,
    especially when both can change over time.

    The bridge pattern promotes loose coupling b/w the abstraction and its implementaion, allowing us to change and extend both independently


    ------------------------------------------Decorator Pattern----------------------------------------------------------

    Decorator Pattern:
    -----------------





















    ---------------------------------------------REPOSITORY PATTERN-------------------------------------------------------
    REPOSITORY PATTERN:
    -------------------
    This acts as an intermediary b/w the business logic and data storage.
    - It impliment de-coupling of the business logic and data access layer.

    - Eg: you may have the repository that stores and retrives data from an in-memory collection, or retrive data from database like SQL server or sharepoint list or webservice

    - Highly Testable, good for testing

    GENERIC REPOSITORY:
    ------------------
    A generic repository is the one that can be used for all the entities.
    - In other words it can be either used for Books or Students or any other entity

    ----------------------------------------------------------------------------------------------------------------------------------------------







</body>
</html>